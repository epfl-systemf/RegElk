From 4516b50cf3dffaba92727ac5a582d51a9caa9222 Mon Sep 17 00:00:00 2001
From: Ludovic Mermod <ludovic.mermod@gmail.com>
Date: Thu, 21 Sep 2023 15:55:34 +0200
Subject: [PATCH 2/3] [regexp] Optimizing non nullable plus in Experimental
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When compiling a quantifier `body{min, max}`, in the special case where
min > 0, max = infinity and body is not nullable, it can be optimized
by using the last mandatory repetition in the following loop. This
reduces the duplication of the bytecode corresponding to the body.

This work was supervised by Aurèle Barrière, from SYSTEMF at EPFL.

Bug: v8:14100
Change-Id: I596b60720ed1d06e402e79047eb2aecf7e079a72
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4778506
Reviewed-by: Patrick Thier <pthier@chromium.org>
Reviewed-by: Jakob Linke <jgruber@chromium.org>
Commit-Queue: Patrick Thier <pthier@chromium.org>
Cr-Commit-Position: refs/heads/main@{#90149}
---
 .../experimental/experimental-compiler.cc     | 145 +++++++++++++++---
 1 file changed, 123 insertions(+), 22 deletions(-)

diff --git a/src/regexp/experimental/experimental-compiler.cc b/src/regexp/experimental/experimental-compiler.cc
index 1ec5a18ffef..01b72f2da60 100644
--- a/src/regexp/experimental/experimental-compiler.cc
+++ b/src/regexp/experimental/experimental-compiler.cc
@@ -84,9 +84,7 @@ class CanBeHandledVisitor final : private RegExpVisitor {
     return nullptr;
   }
 
-  void* VisitAtom(RegExpAtom* node, void*) override {
-    return nullptr;
-  }
+  void* VisitAtom(RegExpAtom* node, void*) override { return nullptr; }
 
   void* VisitText(RegExpText* node, void*) override {
     for (TextElement& el : *node->elements()) {
@@ -124,7 +122,12 @@ class CanBeHandledVisitor final : private RegExpVisitor {
 
     int local_replication;
     if (node->max() == RegExpTree::kInfinity) {
-      local_replication = node->min() + 1;
+      if (node->min() > 0 && node->min_match() > 0) {
+        // Quantifier can be reduced to a non nullable plus.
+        local_replication = std::max(node->min(), 1);
+      } else {
+        local_replication = node->min() + 1;
+      }
     } else {
       local_replication = node->max();
     }
@@ -605,6 +608,62 @@ class CompileVisitor : private RegExpVisitor {
     assembler_.Bind(end);
   }
 
+  // In the general case, the first repetition of <body>+ is different
+  // from the following ones as it is allowed to match the empty string. This is
+  // compiled by repeating <body>, but it can result in a bytecode that grows
+  // quadratically with the size of the regex when nesting pluses or repetition
+  // upper-bounded with infinity.
+  //
+  // In the particular case where <body> cannot match the empty string, the
+  // plus can be compiled without duplicating the bytecode of <body>, resulting
+  // in a bytecode linear in the size of the regex in case of nested
+  // non-nullable pluses.
+  //
+  // E.g. `/.+/` will compile `/./` once, while `/(?:.?)+/` will be compiled as
+  // `/(?:.?)(?:.?)*/`, resulting in two repetitions of the body.
+
+  // Emit bytecode corresponding to /<emit_body>+/, with <emit_body> not
+  // nullable.
+  template <class F>
+  void CompileNonNullableGreedyPlus(F&& emit_body) {
+    // This is compiled into
+    //
+    //   begin:
+    //     <body>
+    //
+    //     FORK end
+    //     JMP begin
+    //   end:
+    //     ...
+    Label begin, end;
+
+    assembler_.Bind(begin);
+    emit_body();
+
+    assembler_.Fork(end);
+    assembler_.Jmp(begin);
+    assembler_.Bind(end);
+  }
+
+  // Emit bytecode corresponding to /<emit_body>+?/, with <emit_body> not
+  // nullable.
+  template <class F>
+  void CompileNonNullableNonGreedyPlus(F&& emit_body) {
+    // This is compiled into
+    //
+    //   begin:
+    //     <body>
+    //
+    //     FORK begin
+    //     ...
+    Label begin;
+
+    assembler_.Bind(begin);
+    emit_body();
+
+    assembler_.Fork(begin);
+  }
+
   void* VisitQuantifier(RegExpQuantifier* node, void*) override {
     // Emit the body, but clear registers occuring in body first.
     //
@@ -620,30 +679,72 @@ class CompileVisitor : private RegExpVisitor {
       node->body()->Accept(this, nullptr);
     };
 
-    // First repeat the body `min()` times.
-    for (int i = 0; i != node->min(); ++i) emit_body();
+    bool can_be_reduced_to_non_nullable_plus =
+        node->min() > 0 && node->max() == RegExpTree::kInfinity &&
+        node->min_match() > 0;
 
-    switch (node->quantifier_type()) {
-      case RegExpQuantifier::POSSESSIVE:
-        UNREACHABLE();
-      case RegExpQuantifier::GREEDY: {
-        if (node->max() == RegExpTree::kInfinity) {
-          CompileGreedyStar(emit_body);
-        } else {
-          DCHECK_NE(node->max(), RegExpTree::kInfinity);
-          CompileGreedyRepetition(emit_body, node->max() - node->min());
+    if (can_be_reduced_to_non_nullable_plus) {
+      // Compile <body>+ with an optimization allowing linear sized bytecode in
+      // the case of nested pluses. Repetitions with infinite upperbound like
+      // <body>{n,}, with n != 0, are compiled into <body>{n-1}<body+>, avoiding
+      // one repetition, compared to <body>{n}<body>*.
+
+      // Compile the mandatory repetitions. We repeat `min() - 1` times, such
+      // that the last repetition, compiled later, can be reused in a loop.
+      for (int i = 0; i < node->min() - 1; ++i) {
+        emit_body();
+      }
+
+      // Compile the optional repetitions, using an optimized plus when
+      // possible.
+      switch (node->quantifier_type()) {
+        case RegExpQuantifier::POSSESSIVE:
+          UNREACHABLE();
+        case RegExpQuantifier::GREEDY: {
+          // Compile both last mandatory repetition and optional ones.
+          CompileNonNullableGreedyPlus(emit_body);
+          break;
+        }
+        case RegExpQuantifier::NON_GREEDY: {
+          // Compile both last mandatory repetition and optional ones.
+          CompileNonNullableNonGreedyPlus(emit_body);
+          break;
         }
-        break;
       }
-      case RegExpQuantifier::NON_GREEDY: {
-        if (node->max() == RegExpTree::kInfinity) {
-          CompileNonGreedyStar(emit_body);
-        } else {
-          DCHECK_NE(node->max(), RegExpTree::kInfinity);
-          CompileNonGreedyRepetition(emit_body, node->max() - node->min());
+    } else {
+      // Compile <body>+ into <body><body>*, and <body>{n,}, with n != 0, into
+      // <body>{n}<body>*.
+
+      // Compile the first `min()` repetitions.
+      for (int i = 0; i < node->min(); ++i) {
+        emit_body();
+      }
+
+      // Compile the optional repetitions, using stars or repetitions.
+      switch (node->quantifier_type()) {
+        case RegExpQuantifier::POSSESSIVE:
+          UNREACHABLE();
+        case RegExpQuantifier::GREEDY: {
+          if (node->max() == RegExpTree::kInfinity) {
+            CompileGreedyStar(emit_body);
+          } else {
+            DCHECK_NE(node->max(), RegExpTree::kInfinity);
+            CompileGreedyRepetition(emit_body, node->max() - node->min());
+          }
+          break;
+        }
+        case RegExpQuantifier::NON_GREEDY: {
+          if (node->max() == RegExpTree::kInfinity) {
+            CompileNonGreedyStar(emit_body);
+          } else {
+            DCHECK_NE(node->max(), RegExpTree::kInfinity);
+            CompileNonGreedyRepetition(emit_body, node->max() - node->min());
+          }
+          break;
         }
       }
     }
+
     return nullptr;
   }
 
-- 
2.34.1

