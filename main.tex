\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{url}
\usepackage{lipsum}
\usepackage{geometry}
\usepackage[tt=false]{libertine}
\usepackage{xcolor}
\bibliographystyle{apalike}
\citestyle{acmauthoryear}   %% For author/year citations
\renewcommand\cite\citep
\usepackage{syntaxdefs}
\usepackage{graphicx}
\usepackage{listings}

\usepackage[bookmarksnumbered,unicode]{hyperref} %Utiliser pour une bibliographie interactive + sommaire et TOC interactifs (pour une sortie PDF, par exemple).
\bibpunct{[}{]}{,}{a}{}{;}

\hypersetup{colorlinks,
      linkcolor=ACMPurple,
      citecolor=ACMPurple,
      urlcolor=ACMDarkBlue,
      filecolor=ACMDarkBlue}

\definecolor[named]{ACMBlue}{cmyk}{1,0.1,0,0.1}
\definecolor[named]{ACMYellow}{cmyk}{0,0.16,1,0}
\definecolor[named]{ACMOrange}{cmyk}{0,0.42,1,0.01}
\definecolor[named]{ACMRed}{cmyk}{0,0.90,0.86,0}
\definecolor[named]{ACMLightBlue}{cmyk}{0.49,0.01,0,0}
\definecolor[named]{ACMGreen}{cmyk}{0.20,0,1,0.19}
\definecolor[named]{ACMPurple}{cmyk}{0.55,1,0,0.15}
\definecolor[named]{ACMDarkBlue}{cmyk}{1,0.58,0,0.21}


\lstdefinestyle{rgx}{ %
  xleftmargin=2\parindent,
  captionpos=b,
  mathescape,
  basicstyle=\ttfamily,
  commentstyle=\itshape\color{MidnightBlue},
  identifierstyle=\color{black},
  keywordstyle=\bfseries,
}

\lstdefinestyle{byt}{ %
  xleftmargin=2\parindent,
  captionpos=b,
  mathescape,
  basicstyle=\ttfamily,
  commentstyle=\itshape\color{MidnightBlue},
  identifierstyle=\color{black},
  keywordstyle=\bfseries,
}


\def\bytecode#1{\lstinline[style=byt]{#1}}
\def\tbytecode#1{\text{\bytecode{#1}}}

\def\regex#1{\lstinline[style=rgx]{#1}}
\def\tregex#1{\text{\regex{#1}}}

\def\todo#1{{\color{ACMOrange}{TODO: }}#1}
\def\undef{\texttt{undefined}}
\def\str#1{\texttt{"#1"}}
\def\group#1{\texttt{\##1}}

\def\size#1{\ensuremath{|#1|}}
\def\psize#1{\ensuremath{||#1||}}
\def\looknb#1{\ensuremath{\mathcal{L}(#1)}}
\def\bigo{\ensuremath{\mathcal{O}}}


\geometry{vmargin=4.0cm}

\title{Regular Epressions with Lookarounds and Capture Groups Can Be Matched Linearly}
\author{}
\date{}



\begin{document}


\maketitle


\section{Context}

\subsection{Preliminaries}
This work is an extension of the bytecode-based NFA-simulation technique used to match regexes with capture groups.
An explanation of this technique can be found here~\cite{regex_vm_approach}. We assume the reader is familiar with this technique.
This approach is used in both Experimental~\cite{experimental} in the V8 JS engine, and in the linear engine RE2~\cite{re2}.
Using this technique, given a string $s$ of size $\size{s}$ and a regex $r$ or size $\size{r}$, the matching complexity (in both time and space) is $\bigo(\size{s}*\size{r})$.

In particular, we reuse the "Pike Implementation" for capture groups where threads are ordered by priority to handle ambiguous submatching.
But in this work, we extend the algorithm to also be able to match lookarounds in regexes in linear time and space.
This feature was previously famously unsupoprted by linear regex engines~\cite{re2_unsupported}.


\subsection{Syntax}
We consider the following grammar of regular expressions:

\def\re{\ensuremath{\mathit{e}}}
\def\char{\ensuremath{\mathit{c}}}
\def\quant{\ensuremath{\mathit{q}}}
\def\look{\ensuremath{\mathit{lk}}}

\begin{figure}[h]
  \begin{syntax}
    \syntaxclass{Regular Expressions:}
\re & ::= & \char & Character \\
&\mid& . & Any Character\\
&\mid& \re_1 ~ \re_2 & Concatenation\\
&\mid& \re_1 \tregex{|} \re_2 & Union\\
&\mid&  \re ~ \quant & Quantifier \\
&\mid&  \tregex{(}\re\tregex{)} & Capture Group \\
&\mid& \tregex{(}\look~\re\tregex{)} & Lookaround \\
%% &\mid& \tregex{(?=}\re\tregex{)} & Positive Lookahead \\
%% &\mid& \tregex{(?!}\re\tregex{)} & Negative Lookahead \\
%% &\mid& \tregex{(?<=}\re\tregex{)} & Positive Lookbehind \\
%% &\mid& \tregex{(?<!}\re\tregex{)} & Negative Lookbehind \\
%
\syntaxclass{Quantifiers:}
\quant & ::=& \tregex{*} & Greedy Star\\
&\mid& \tregex{*?} & Lazy Star\\
&\mid& \tregex{+} & Greedy Plus\\
&\mid& \tregex{+?} & Lazy Plus\\
%
\syntaxclass{Lookarounds:}
\look & ::=& \tregex{?=} & Positive Lookahead\\
&\mid& \tregex{?!} & Negative Lookahead\\
&\mid& \tregex{?<=} & Positive Lookbehind\\
&\mid& \tregex{?<!} & Negative Lookbehind\\
  \end{syntax}
\end{figure}

\subsection{Semantics}
\subsubsection{Lookaround Semantics}
\todo{semantics}
\cite{ecma_262}\cite{rewla}


\subsubsection{Semantic Properties}
Here are some notable properties of the semantics, that may separate it from other extended regex languages.
Note that all these properties are properties of the JS regex language as well.

\paragraph{Unbounded Lookarounds}
Some languages (\emph{e.g.} Perl, Python, Java) only allow fixed-width lookarounds. Meaning that regular expression patterns inside lookaheads and lookbehinds should not contain quantifiers.
Here, we allow lookarounds with quantifiers.
For example, the regular expression \regex{(?=a*)} is allowed.

\paragraph{Capture Reset}
When executing a quantifier, the value of the capture groups defined inside that quantifier are reset to \undef.
For instance, matching \regex{((a)|(b))*} on string \str{ab} will return a match where group \group{2} is set to undefined.
On the first star iteration, \group{2} was set to the capture value \texttt{[0-1]}, matching the first character of the string.
When executing the second star iteration, \group{2} is reset to undefined, and group \group{3} is set to \texttt{[1-2]}, matching character \texttt{b}.
This means that only the last iteration of a quantifier in a successful match will set the values of the groups defined inside that quantifier.
This property holds for the JS regex language, but the behavior differs in the regex languages of Perl, Python, Java and .NET.

\paragraph{No negative captures}
Note that negative lookahead and negative lookbehinds do not define any capture groups.
You can write the regular expression \regex{(?!(a))}, but group \group{1} will always be \undef.
As a result, \regex{(?!(?!e))} is not equivalent to \regex{(?=e)}.
This appears to be a property shared by most regex languages with negative lookarounds.

\paragraph{Quantifiers that did not consume any characters do not capture anything}
Lookarounds do not consume characters, meaning that the current position of the string does not change after matching a lookaround.
If the regular expression inside a quantifier does not consume any character, then the capture groups values inside that quantifiers are discarded.
For instance, when matching \regex{(?=(a))*a} on string \str{a}, capture group \group{1} will be \undef.
This property holds for the JS regex language, but the behavior differs in the regex languages of Perl, Python, Java and .NET.

\todo{add a property about empty captures and lazy stars}

\section{A Linear Algorithm for Loookarounds and Capture Groups}

\subsection{Preliminary Definitions}

Before describing our algorithm, we need the following definitions.

\paragraph{Capture Group Annotations}
We annotate each regex with a different identifier for each capture group.
Some regex languages (like .NET) allow different capture groups to have the same identifiers using named capture groups.
Others (like JS, PCRE and Java) disallow this. In this work, we associate unique identifiers to each capture group.

% TODO: why does using the regex macro not work here with subscript???
For instance, the regex \regex{a(b)(c)} gets annotated to \lstinline[style=rgx]{a$(b)_{\#1}$(c)$_{\#2}$} and \regex{a((b))} gets annotated to \lstinline[style=rgx]{a((b)$_{\#2}$)$_{\#1}$}.
Groups are annotated in order of a depth-first AST traversal, starting with 1.
Before matching a regex, we add a new capture group around the entire expression annotated with index 0, mimicking the JS behavior.

\paragraph{Lookaround Annotations}
Similarly, we annotate each lookaround with an unique identifier.
Identifiers are integers given in order of a depth-first AST traversal.
This ensures that if lookaround $l_{\Box1}$ contains another lookaround $l_{\Box2}$, then the index of $l_{\Box1}$ is smaller than the index of $l_{\Box2}$.
For instance, the regex \regex{(?=a(?<=a))a} gets annotated to \lstinline[style=rgx]{(?=$_{\Box1}$a(?<=$_{\Box2}$a))a}.
We write \looknb{r} the total number of lookarounds in a regex $r$.
For instance, $\looknb{(\tregex{(?=a(?<=a))a})} = 2$.

\subsection{Main Intuitions}

\paragraph{Issue:}
For a regular expression with lookarounds, trying to reuse the NFA-simulation technique, with a single traversal of the input string, is difficult.
What should we do when a thread encounters a lookaround? The main issue lies in the fact that some paths should not be explored, but we don't know ahead-of-time which ones.
\begin{itemize}
\item We could suspend the execution, and run another regex matcher to determine if the lookaround is verified.
  This will not have a linear complexity in the size of the string. For a regex like \regex{(a(?=a*))*)} on a string repeating the character \str{a}, this will have us perform a regex matching problem on each possible suffix of the string.
\item For lookaheads, we could try to run in parallel two state machines: one for the outer sub-expression, and one for the sub-expression inside the lookahead. Threads would then consist in a pair of states.
  This will not have a linear complexity in the size of the regex, since the number of possible threads that cannot be merged together explodes with each lookahead.
\end{itemize}


\paragraph{Intuition:}
These issues disappear if we know in advance, for each lookaround, at which positions in the input string it holds.
For instance, if we know that lookaround \regex{(?=a)} on input string \str{abac} holds at positions 0 and 2.
Then, when compiling a regex with lookarounds to bytecode, we can simply generate for each lookaround a bytecode instruction that kills the current thread if this lookaround does not hold at the current string position.


\paragraph{Notations:}
From now on, we consider the problem of regex matching a regex $r$ with lookarounds on an input string $s$.
The size of $r$ (as in the number of nodes in its AST), is noted \size{r}.
The number of lookarounds in $r$ is noted \looknb{r}.
$r_{\Box i}$ denotes the sub-expression inside the lookaround annotated with $i$ in $r$.
For instance, \lstinline[style=rgx]{a(?=$_1$(b|c))c$_{\Box 1}$} = \regex{(b|c)}. 
The \textit{proper size} of a regex $r$, noted \psize{r}, is defined to be the number of nodes in its AST without descending recursively inside lookarounds.
We get the following equality, expressing that the full size of a regex is equal to the sum of its proper size and the proper sizes of all its lookarounds:
$$\forall r, \size{r} = \psize{r} + \sum_{i=1}^{\looknb{r}}\psize{r_{\Box i}}$$

The length of a string $s$ is noted \size{s}.
A \textit{position} in a string $s$ corresponds to an integer between 0 and $\size{s}+1$.
The positions correspond to places in-between characters of the string.
Asymptotical complexities are noted using \bigo~ notations.



\paragraph{Overview of our algorithm:}

Following this intuition, we present the following algorithm:

\begin{itemize}
\item First, we build an \textit{oracle}, an 2-dimension array of booleans of size $(\looknb{r}, \size{s}+1)$.
  At the end of this first step, \textit{oracle} contains \textit{true} at row $i$ and column $j$ if and only if the lookaround annotated with $i$ holds at position $j$ in the input string.
\item Then, we can match $r$ using a standard simulation technique. Whenever a thread encounters a lookaround, it simply checks the oracle. If a match is found, we extract the capture groups defined in $r$ that are not contained inside lookarounds.
\item Finally, we reconstruct the missing capture groups defined inside lookarounds.
\end{itemize}

  
\subsection{Bytecode}

The bytecode we generate consists in lists of instructions described by the following grammar:

\def\instr{\ensuremath{\mathit{e}}}
\def\lbl{\ensuremath{\mathit{l}}}
\def\reg{\ensuremath{\mathit{reg}}}
\def\lid{\ensuremath{\mathit{lid}}}

\begin{figure}[h]
  \begin{syntax}
    \syntaxclass{Instructions:}
    \instr & ::= & \tbytecode{Consume}~\char & Consume the character \char \\
    &\mid& \tbytecode{ConsumeAll} & Consume any character\\
    &\mid& \tbytecode{Jump}~\lbl & Jumps to label~\lbl\\
    &\mid& \tbytecode{Fork}~\lbl_1~\lbl_2 & Creates a new thread. \lbl$_1$ has higher priority \\
    &\mid& \tbytecode{Accept} & A match is found\\
    &\mid& \tbytecode{SetRegisterToCP}~\reg & Writes the current CP value to a register \reg \\
    &\mid& (\tbytecode{ClearRegister}~\reg) & Clears the value of a register \\
    &\mid& \tbytecode{WriteOracle}~\lid & Writes the current CP value to the oracle, in row \lid \\
    &\mid& \tbytecode{CheckOracle}~\lid & Checks that the oracle is true \\
    &\mid& \tbytecode{NegCheckOracle}~\lid & Checks that the oracle is false \\
    &\mid& (\tbytecode{ClearMemory}~\lid) & Clears the value \lid of the lookaround memory\\
  \end{syntax}
\end{figure}

Labels \lbl~ correspond to indices of the list.

\subsection{Bytecode Compilation}
This section describes how we generate bytecode from a regex.
Much of this is similar to the classic lookaround-free case~\cite{regex_vm_approach}.

We recursively define the function \texttt{compile}, transforming a regex AST into a list of bytecode instructions.
Instructions labels are given names followed by colons \texttt{:}.

\begin{tabular}{l p{6cm}}
  \regex{c} & \bytecode{Consume}~\regex{c}\\
  \hline
  \regex{.} & \bytecode{ConsumeAll}\\
  \hline
  $\re_1~\re_2$ & \texttt{compile}$(\re_1)$\newline\texttt{compile}$(\re_2)$ \\
  \hline
  $\re_1~|~\re_2$ & \bytecode{Fork l1 l2}\newline\texttt{l1: compile}$(\re_1)$\newline
  \bytecode{Jump end}\newline\texttt{l2: compile}$(\re_2)$\newline\texttt{end: ...}\\
  \hline
  $(\re)_{\#c}$ & \bytecode{SetRegisterToCP}$(2 * r)$\newline\texttt{compile}$(\re)$\newline\bytecode{SetRegisterToCP}$((2*r)+1)$\\
  \hline
  $\re$\tregex{*} & \bytecode{star: Fork body end}\newline\bytecode{body: Clear}\todo{clearing and other quantifiers}\newline
  \texttt{compile}$(\re)$\newline\bytecode{Jump star}\newline\texttt{end: ...}\\
  \hline
  \regex{(?=}$_{\Box i}$\re\regex{)} & \bytecode{CheckOracle i}\\
  \hline
  \regex{(?<=}$_{\Box i}$\re\regex{)} & \bytecode{CheckOracle i}\\
  \hline
  \regex{(?!}$_{\Box i}$\re\regex{)} & \bytecode{NegCheckOracle i}\\
  \hline
  \regex{(?<!}$_{\Box i}$\re\regex{)} & \bytecode{NegCheckOracle i}\\
\end{tabular}

\paragraph{Bytecode size property}
The bytecode size (number of instructions) of \texttt{compile}$(\re)$ is linear in the proper size of $\re$: $\bigo(\psize{\re})$.
\todo{not true with the plus and clearing}


\subsection{First Step: Constructing the Oracle}

The first step of the algorithm consists in building the oracle, the array that indicates for each lookaround of the regex, at which position in the input string it holds.

\paragraph{Constructing one row of the oracle}
Finding all the places where a lookaround subexpression $e_{\Box i}$ is true can be done by matching it \textit{in reverse}.
First, one constructs the reverse of $e_{\Box i}$, $\mathit{rev}(e_{\Box i})$ by recursively inverting the two subexpressions of each concatenation in $e_{\Box i}$.
We compile to bytecode \regex{.*?}$\mathit{rev(\re_{\Box i})}$ and replace its last \bytecode{Accept} instruction with a \bytecode{WriteOracle i} instruction.
Then, we extend a standard NFA-simulation matcher by allowing it to read the input string backward, starting with the last character of the string, then moving toward its beginning.
We will use the standard forward direction for lookbheinds and negative lookbehinds, and the backward direction for lookaheads and negative lookaheads.

Since a lookaround may depend on the result of another lookaround defined inside, we consider lookarounds from the highest to lowest indices.

\paragraph{First step complexity}
For each lookaround, we run a NFA-simulation on the entire string.
The bytecode size of each lookaround is linear with its \textit{proper size}.
As a result, for each lookaround $\re_{\Box i}$, constructing the $i$-th row of the oracle has time complexity $\bigo(\size{s} * \psize{\re_{\Box i}})$.
Finally, the complexity of building the entire oracle is $\bigo(\sum_{i=1}^{\looknb{r}} \size{s} * \psize{\re_{\Box i}})$.
Usig the proper size equality, this is $\bigo(\size{s} * \size{\re})$.

The asymptotical space complexity of this first step is also $\bigo(\size{s} * \size{\re})$, given that both the array itself and each NFA-simulation have this complexity.


\paragraph{Remark on using lazy-DFA matchers}
In that step capture groups do not matter, and we can freely remove them from each lookaround subexpression.
As a result, one could use a lazy-DFA matcher instead of the NFA-simulation technique.
The lazy-DFA approach does not order threads by priority, but instead considers unordered sets of threads.
This allows for faster matching, at the cost of not extracting the capture groups.
An engine like RE2 already contains both NFA-simulation and lazy-DFA matching.

\paragraph{Remark on streaming mode}
An engine like RE2 only ever reads the input string from its beginning to its end.
As a result, it can also work in streaming mode, where the input string is being processed on-the-fly;
Due to the fact that we analyze lookaheads and negative lookaheads in the backward direction, our algorithm is not compatible with streaming mode.




\subsection{Second Step: Finding Capture Groups}

\section{Complexity Analysis}

\section{Limitations}

\section{Conclusion}



\newpage
\bibliography{main.bib}

\end{document}
