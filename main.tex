\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{url}
\usepackage{lipsum}
\usepackage{geometry}
\usepackage[tt=false]{libertine}
\usepackage{xcolor}
\bibliographystyle{apalike}
\citestyle{acmauthoryear}   %% For author/year citations
\renewcommand\cite\citep
\usepackage{syntaxdefs}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[ruled,vlined]{algorithm2e} %% for the pseudocode

\usepackage[bookmarksnumbered,unicode]{hyperref} %Utiliser pour une bibliographie interactive + sommaire et TOC interactifs (pour une sortie PDF, par exemple).
\bibpunct{[}{]}{,}{a}{}{;}

\hypersetup{colorlinks,
      linkcolor=ACMPurple,
      citecolor=ACMPurple,
      urlcolor=ACMDarkBlue,
      filecolor=ACMDarkBlue}

\definecolor[named]{ACMBlue}{cmyk}{1,0.1,0,0.1}
\definecolor[named]{ACMYellow}{cmyk}{0,0.16,1,0}
\definecolor[named]{ACMOrange}{cmyk}{0,0.42,1,0.01}
\definecolor[named]{ACMRed}{cmyk}{0,0.90,0.86,0}
\definecolor[named]{ACMLightBlue}{cmyk}{0.49,0.01,0,0}
\definecolor[named]{ACMGreen}{cmyk}{0.20,0,1,0.19}
\definecolor[named]{ACMPurple}{cmyk}{0.55,1,0,0.15}
\definecolor[named]{ACMDarkBlue}{cmyk}{1,0.58,0,0.21}


\lstdefinestyle{rgx}{ %
  xleftmargin=2\parindent,
  captionpos=b,
  mathescape,
  basicstyle=\ttfamily,
  commentstyle=\itshape\color{MidnightBlue},
  identifierstyle=\color{black},
  keywordstyle=\bfseries,
}

\lstdefinestyle{byt}{ %
  xleftmargin=2\parindent,
  captionpos=b,
  mathescape,
  basicstyle=\ttfamily,
  commentstyle=\itshape\color{MidnightBlue},
  identifierstyle=\color{black},
  keywordstyle=\bfseries,
}


\def\bytecode#1{\lstinline[style=byt]{#1}}
\def\tbytecode#1{\text{\bytecode{#1}}}

\def\regex#1{\lstinline[style=rgx]{#1}}
\def\tregex#1{\text{\regex{#1}}}

\def\todo#1{{\color{ACMOrange}{TODO: }}#1}
\def\undef{\texttt{undefined}}
\def\str#1{\texttt{"#1"}}
\def\group#1{\texttt{\##1}}

\def\size#1{\ensuremath{|#1|}}
\def\psize#1{\ensuremath{||#1||}}
\def\looknb#1{\ensuremath{\mathcal{L}(#1)}}
\def\bigo{\ensuremath{\mathcal{O}}}


\geometry{vmargin=4.0cm}

\title{Regular Epressions with Lookarounds and Capture Groups Can Be Matched Linearly}
\author{}
\date{}



\begin{document}


\maketitle


\section{Context}

\subsection{Preliminaries}
This work is an extension of the bytecode-based NFA-simulation technique used to match regexes with capture groups.
An explanation of this technique can be found here~\cite{regex_vm_approach}. We assume the reader is familiar with this technique.
This approach is used in both Experimental~\cite{experimental} in the V8 JS engine, and in the linear engine RE2~\cite{re2}.
Using this technique, given a string $s$ of size $\size{s}$ and a regex $r$ or size $\size{r}$, the matching complexity (in both time and space) is $\bigo(\size{s}*\size{r})$.

In particular, we reuse the "Pike Implementation" for capture groups where threads are ordered by priority to handle ambiguous submatching.
But in this work, we extend the algorithm to also be able to match lookarounds in regexes in linear time and space.
This feature was previously famously unsupoprted by linear regex engines~\cite{re2_unsupported}.


\subsection{Syntax}
We consider a grammar of regular expressions depicted on Figure~\ref{fig:syntax}.

\def\re{\ensuremath{\mathit{e}}}
\def\char{\ensuremath{\mathit{c}}}
\def\quant{\ensuremath{\mathit{q}}}
\def\look{\ensuremath{\mathit{lk}}}

\begin{figure}[h]
  \begin{syntax}
    \syntaxclass{Regular Expressions:}
\re & ::= & \char & Character \\
&\mid& . & Any Character\\
&\mid& \re_1 ~ \re_2 & Concatenation\\
&\mid& \re_1 \tregex{|} \re_2 & Union\\
&\mid&  \re ~ \quant & Quantifier \\
&\mid&  \tregex{(}\re\tregex{)} & Capture Group \\
&\mid& \tregex{(}\look~\re\tregex{)} & Lookaround \\
%% &\mid& \tregex{(?=}\re\tregex{)} & Positive Lookahead \\
%% &\mid& \tregex{(?!}\re\tregex{)} & Negative Lookahead \\
%% &\mid& \tregex{(?<=}\re\tregex{)} & Positive Lookbehind \\
%% &\mid& \tregex{(?<!}\re\tregex{)} & Negative Lookbehind \\
%
\syntaxclass{Quantifiers:}
\quant & ::=& \tregex{*} & Greedy Star\\
&\mid& \tregex{*?} & Lazy Star\\
&\mid& \tregex{+} & Greedy Plus\\
&\mid& \tregex{+?} & Lazy Plus\\
%
\syntaxclass{Lookarounds:}
\look & ::=& \tregex{?=} & Positive Lookahead\\
&\mid& \tregex{?!} & Negative Lookahead\\
&\mid& \tregex{?<=} & Positive Lookbehind\\
&\mid& \tregex{?<!} & Negative Lookbehind\\
  \end{syntax}
  \label{fig:syntax}
  \caption{Regex Syntax}
\end{figure}

Note that when writing down regexes, we also use the notation \regex{(?:e)} to denote a \textit{non-capturing group}.
Such non-capturing groups are just annotations to make parsing unambiguous, but don't introduce any capture groups to extract.


\subsection{Semantics}
\subsubsection{Lookaround Semantics}
\todo{semantics}
\cite{ecma_262}\cite{rewla}


\subsubsection{Semantic Properties}
Here are some notable properties of the semantics, that may separate it from other extended regex languages.
Note that all these properties are properties of the JS regex language as well.

\paragraph{Unbounded Lookarounds}
Some languages (\emph{e.g.} Perl, Python, Java) only allow fixed-width lookarounds. Meaning that regular expression patterns inside lookaheads and lookbehinds should not contain quantifiers.
Here, we allow lookarounds with quantifiers.
For example, the regular expression \regex{(?=a*)} is allowed.

\paragraph{Capture Reset}
When executing a quantifier, the value of the capture groups defined inside that quantifier are reset to \undef.
For instance, matching \regex{((a)|(b))*} on string \str{ab} will return a match where group \group{2} is set to undefined.
On the first star iteration, \group{2} was set to the capture value \texttt{[0-1]}, matching the first character of the string.
When executing the second star iteration, \group{2} is reset to undefined, and group \group{3} is set to \texttt{[1-2]}, matching character \texttt{b}.
This means that only the last iteration of a quantifier in a successful match will set the values of the groups defined inside that quantifier.
This property holds for the JS regex language, but the behavior differs in the regex languages of Perl, Python, Java and .NET.

\paragraph{No negative captures}
Note that negative lookahead and negative lookbehinds do not define any capture groups.
You can write the regular expression \regex{(?!(a))}, but group \group{1} will always be \undef.
As a result, \regex{(?!(?!e))} is not equivalent to \regex{(?=e)}.
This appears to be a property shared by most regex languages with negative lookarounds.

\paragraph{Quantifiers that did not consume any characters do not capture anything}
Lookarounds do not consume characters, meaning that the current position of the string does not change after matching a lookaround.
If the regular expression inside a quantifier does not consume any character, then the capture groups values inside that quantifiers are discarded.
For instance, when matching \regex{(?=(a))*a} on string \str{a}, capture group \group{1} will be \undef.
This property holds for the JS regex language, but the behavior differs in the regex languages of Perl, Python, Java and .NET.

\todo{this might just be a consequence of the property below}
\todo{add a property about empty captures and lazy stars}

\paragraph{Empty Quantifiers}
Iterations of a quantifier that match the empty character sequence are not considered.
This prevents an implementation from going into an infinite loop.
Note that this version of dealing with empty repetition is different in JS than in other languages like Perl, Python, Golang, Java, .NET and Rust.
In JS, any non-empty quantifier iteration is valid.
In other languages, iterations can be invalid if one goes back to the same point inside a quantifier without having consumed anything.
To understand the subtle difference, consider the following regex: \regex{((a|)(|b))*} on string \str{ab}.

In JS, the correct result is to match the entire string \str{ab} in two iterations of the star.
The first iteration matches \str{a} in the first alternation and the empty string in the second alternation.
The second alternation matches the empty string in the first alternation, and \str{b} in the second alternation.
Both of these iterations of the star have matched a non-empty part of the string, \str{a} and \str{b}.

In other languages however, the correct result is to simply match \str{a} in a single iteration.
The first iteration is exactly the same and matches \str{a} in the first alternation and the empty string in the second alternation, following from the fact that left branches have top priority in alternations.
However, doing a second iteration of the star is invalid, since we would end up at the same point in the expression inside the star (between the two alternations) without having consumed anything from the string yet.
We then exit the loop, having matched only \str{a}.





\section{A Linear Algorithm for Loookarounds and Capture Groups}

\subsection{Preliminary Definitions}

Before describing our algorithm, we need the following definitions.

\paragraph{Capture Group Annotations}
We annotate each regex with a different identifier for each capture group.
Some regex languages (like .NET) allow different capture groups to have the same identifiers using named capture groups.
Others (like JS, PCRE and Java) disallow this. In this work, we associate unique identifiers to each capture group.

% TODO: why does using the regex macro not work here with subscript???
For instance, the regex \regex{a(b)(c)} gets annotated to \lstinline[style=rgx]{a$(b)_{\#1}$(c)$_{\#2}$} and \regex{a((b))} gets annotated to \lstinline[style=rgx]{a((b)$_{\#2}$)$_{\#1}$}.
Groups are annotated in order of a depth-first AST traversal, starting with 1.
Before matching a regex, we add a new capture group around the entire expression annotated with index 0, mimicking the JS behavior.

\paragraph{Lookaround Annotations}
Similarly, we annotate each lookaround with an unique identifier.
Identifiers are integers given in order of a depth-first AST traversal.
This ensures that if lookaround $l_{\Box1}$ contains another lookaround $l_{\Box2}$, then the index of $l_{\Box1}$ is smaller than the index of $l_{\Box2}$.
For instance, the regex \regex{(?=a(?<=a))a} gets annotated to \lstinline[style=rgx]{(?=$_{\Box1}$a(?<=$_{\Box2}$a))a}.
We write \looknb{r} the total number of lookarounds in a regex $r$.
For instance, $\looknb{(\tregex{(?=a(?<=a))a})} = 2$.

\subsection{Main Intuitions}

\paragraph{Issue:}
For a regular expression with lookarounds, trying to reuse the NFA-simulation technique, with a single traversal of the input string, is difficult.
What should we do when a thread encounters a lookaround? The main issue lies in the fact that some paths should not be explored, but we don't know ahead-of-time which ones.
\begin{itemize}
\item We could suspend the execution, and run another regex matcher to determine if the lookaround is verified.
  This will not have a linear complexity in the size of the string. For a regex like \regex{(a(?=a*))*} on a string repeating the character \str{a}, this will have us perform a regex matching problem on each possible suffix of the string.
\item For lookaheads, we could try to run in parallel two state machines: one for the outer sub-expression, and one for the sub-expression inside the lookahead. Threads would then consist in a pair of states.
  This will not have a linear complexity in the size of the regex, since the number of possible threads that cannot be merged together explodes with each lookahead.
\end{itemize}


\paragraph{Intuition:}
These issues disappear if we know in advance, for each lookaround, at which positions in the input string it holds.
For instance, if we know that lookaround \regex{(?=a)} on input string \str{abac} holds at positions 0 and 2.
Then, when compiling a regex with lookarounds to bytecode, we can simply generate for each lookaround a bytecode instruction that kills the current thread if this lookaround does not hold at the current string position.
In our algorithm we show that it is in fact possible to know for each lookaround at which position in the string it holds, and that this can be done in time and space linear complexity, in both the size of the input string and the size of the regex.


\paragraph{Notations:}
From now on, we consider the problem of regex matching a regex $r$ with lookarounds on an input string $s$.
The size of $r$ (as in the number of nodes in its AST), is noted \size{r}.
The number of lookarounds in $r$ is noted \looknb{r}.
$r_{\Box i}$ denotes the sub-expression inside the lookaround annotated with $i$ in $r$.
For instance, \lstinline[style=rgx]{a(?=$_1$(b|c))c$_{\Box 1}$} = \regex{(b|c)}. 
The \textit{intrinsic size} of a regex $r$, noted \psize{r}, is defined to be the number of nodes in its AST without descending recursively inside lookarounds.
We get the following equality, expressing that the full size of a regex is equal to the sum of its intrinsic size and the intrinsic sizes of all its lookarounds:
$$\forall r, \size{r} = \psize{r} + \sum_{i=1}^{\looknb{r}}\psize{r_{\Box i}}$$

The length of a string $s$ is noted \size{s}.
A \textit{position} in a string $s$ corresponds to an integer between 0 and $\size{s}+1$.
The positions correspond to places in-between characters of the string.
Asymptotical complexities are noted using \bigo~ notations.



\paragraph{Overview of our algorithm:}

Following this intuition, we present the following algorithm:

\begin{itemize}
\item First, we build an \textit{oracle}, an 2-dimension array of booleans of size $(\looknb{r}, \size{s}+1)$.
  At the end of this first step, \textit{oracle} contains \textit{true} at row $i$ and column $j$ if and only if the lookaround annotated with $i$ holds at position $j$ in the input string.
\item Then, we can match $r$ using a standard simulation technique. Whenever a thread encounters a lookaround, it simply checks the oracle. If a match is found, we extract the capture groups defined in $r$ that are not contained inside lookarounds.
\item Finally, we reconstruct the missing capture groups defined inside lookarounds.
\end{itemize}

  
\subsection{Bytecode}

The bytecode we generate consists in lists of instructions described by grammar depicted on Figure~\ref{fig:bytecode}.

\def\instr{\ensuremath{\mathit{e}}}
\def\lbl{\ensuremath{\mathit{l}}}
\def\reg{\ensuremath{\mathit{reg}}}
\def\lid{\ensuremath{\mathit{lid}}}

\begin{figure}[h]
  \begin{syntax}
    \syntaxclass{Instructions:}
    \instr & ::= & \tbytecode{Consume}~\char & Consume the character \char \\
    &\mid& \tbytecode{ConsumeAll} & Consume any character\\
    &\mid& \tbytecode{Jump}~\lbl & Jumps to label~\lbl\\
    &\mid& \tbytecode{Fork}~\lbl_1~\lbl_2 & Creates a new thread. \lbl$_1$ has higher priority \\
    &\mid& \tbytecode{Accept} & A match is found\\
    &\mid& \tbytecode{SetRegisterToCP}~\reg & Writes the current CP value to a register \reg \\
    &\mid& (\tbytecode{ClearRegister}~\reg) & Clears the value of a register \\
    &\mid& \tbytecode{WriteOracle}~\lid & Writes the current CP value to the oracle, in row \lid \\
    &\mid& \tbytecode{CheckOracle}~\lid & Checks that the oracle is true \\
    &\mid& \tbytecode{NegCheckOracle}~\lid & Checks that the oracle is false \\
    &\mid& (\tbytecode{ClearMemory}~\lid) & Clears the value \lid of the lookaround memory\\
  \end{syntax}
  \label{fig:bytecode}
  \caption{The different bytecode instructions}
\end{figure}

Labels \lbl~ correspond to indices of the list.

\subsection{Bytecode Compilation}
This section describes how we generate bytecode from a regex.
Much of this is similar to the classic lookaround-free case~\cite{regex_vm_approach}.

We recursively define the function \texttt{compile}, transforming a regex AST into a list of bytecode instructions.
Instructions labels are given names followed by colons \texttt{:}.

\begin{tabular}{l p{6cm}}
  \regex{c} & \bytecode{Consume}~\regex{c}\\
  \hline
  \regex{.} & \bytecode{ConsumeAll}\\
  \hline
  $\re_1~\re_2$ & \texttt{compile}$(\re_1)$\newline\texttt{compile}$(\re_2)$ \\
  \hline
  $\re_1~|~\re_2$ & \bytecode{Fork l1 l2}\newline\texttt{l1: compile}$(\re_1)$\newline
  \bytecode{Jump end}\newline\texttt{l2: compile}$(\re_2)$\newline\texttt{end: ...}\\
  \hline
  $(\re)_{\#c}$ & \bytecode{SetRegisterToCP}$(2 * r)$\newline\texttt{compile}$(\re)$\newline\bytecode{SetRegisterToCP}$((2*r)+1)$\\
  \hline
  $\re$\tregex{*} & \bytecode{star: Fork body end}\newline\bytecode{body: Clear}\todo{clearing and other quantifiers}\newline
  \texttt{compile}$(\re)$\newline\bytecode{Jump star}\newline\texttt{end: ...}\\
  \hline
  \regex{(?=}$_{\Box i}$\re\regex{)} & \bytecode{CheckOracle i}\\
  \hline
  \regex{(?<=}$_{\Box i}$\re\regex{)} & \bytecode{CheckOracle i}\\
  \hline
  \regex{(?!}$_{\Box i}$\re\regex{)} & \bytecode{NegCheckOracle i}\\
  \hline
  \regex{(?<!}$_{\Box i}$\re\regex{)} & \bytecode{NegCheckOracle i}\\
\end{tabular}

\paragraph{Bytecode size property}
The bytecode size (number of instructions) of \texttt{compile}$(\re)$ is linear in the intrinsic size of $\re$: $\bigo(\psize{\re})$.
\todo{not true with the plus and clearing}


\subsection{The VM - Executing the Bytecode}

In this section, we show how the VM executes the bytecode we generate for each regex.
Note that this mostly consists in adapting the technique described in~\cite{regex_vm_approach}.

For \texttt{advance\_epsilon}, we simply add new cases for the new bytecode instructions.
For the VM itself, we simply add the possibility of matching the string $s$ in reverse, going from position $\size{s}$ to position 0.
We also add the possibility of starting at a given string position.

\todo{show the algorithms for advanceepislon, consume, and the vm}
\todo{maybe highlight the changes that are specific to lookarounds: new instructions, new VM arguments, and direction}

\subsection{First Step: Constructing the Oracle}

The first step of the algorithm consists in building the oracle, the array that indicates for each lookaround of the regex, at which position in the input string it holds.

\paragraph{Constructing one row of the oracle}
Finding all the places where a lookaround subexpression $e_{\Box i}$ is true can be done by matching it \textit{in reverse}.
First, one constructs the reverse of $e_{\Box i}$, $\mathit{rev}(e_{\Box i})$ by recursively inverting the two subexpressions of each concatenation in $e_{\Box i}$.
We compile to bytecode \regex{.*?}$\mathit{rev(\re_{\Box i})}$ and replace its last \bytecode{Accept} instruction with a \bytecode{WriteOracle i} instruction.
Then, we extend a standard NFA-simulation matcher by allowing it to read the input string backward, starting with the last character of the string, then moving toward its beginning.
We will use the standard forward direction for lookbehinds and negative lookbehinds, and the backward direction for lookaheads and negative lookaheads.

Since a lookaround may depend on the result of another lookaround defined inside, we consider lookarounds from the highest to lowest indices.


\paragraph{Remark on using lazy-DFA matchers}
In that step capture groups do not matter, and we can freely remove them from each lookaround subexpression.
As a result, one could use a lazy-DFA matcher instead of the NFA-simulation technique.
The lazy-DFA approach does not order threads by priority, but instead considers unordered sets of threads.
This allows for faster matching, at the cost of not extracting the capture groups.
An engine like RE2 already contains both NFA-simulation and lazy-DFA matching.


\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\SetKwFor{match}{match}{with}{end}
\SetKwFor{case}{case}{\texttt{=>}}{}
\SetKw{hlet}{let}
\SetAlgoLined
\Input{A regex $e$ and a string $s$}
\Output{An oracle $o$ indicating the positions where each lookaround holds}
\hlet \texttt{o = Array(}$(\looknb{e}, \size{s}+1)$\texttt{,false)}\;
\For{i=$\looknb{e}$ \textbf{down to} 1}{
  \hlet{look = $\mathit{rev}(e_{\Box i})$}\;
  \hlet{bc = compile(\regex{.*?}look)}\;
  \match{$e_{\Box i}$}{
    \case{Lookahead or NegativeLookahead}{VM(bc, $s$, $o$, backward)}
    \case{Lookbehind or NegativeLookbehind}{VM(bc, $s$, $o$, forward)}
  }
}
\Return $o$\;
\caption{Building the oracle, \texttt{build\_oracle}}\label{alg:oracle}
\end{algorithm}

\todo{in another section, rewrite the algorithm for the VM, highlighting what's new compared to the previous version.}
\todo{also find a way to express that this compilation does not use Accept but WriteOracle}

The algorithm for the first step of our technique is shown on Algorithm~\ref{alg:oracle}.
Note that in this step, we ignore the output of $\mathit{VM}$.
Instead of returning matches, each call to $\mathit{VM}$ will write to the oracle $o$ each time a match is found.

\todo{explain in more details why this works, why the lazy star, why the direction change\dots}


\subsection{Second Step: Running the main expression}

Now that we know the positions at which each lookaround holds, we can simply run the main expression in a forward direction.
Whenever a thread encounters a lookaround, it will simply access the oracle.
This step is shown on Algorithm~\ref{alg:main}.
The main expression $e$ is wrapped around te capture group \#0.
When this finds a match, this returns both $c$, the register values for all capture groups defined inside the main expression,
and $m$, indicating the last position in the string each lookaround was used to find a match.
The only missing thing is the values of the capture groups defined inside positive lookarounds.
We reconstruct them in the final step of the algorithm in the next section, using $get\_missing\_captures$.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\SetKwFor{match}{match}{with}{end}
\SetKwFor{case}{case}{\texttt{=>}}{}
\SetKw{hlet}{let}
\SetAlgoLined
\Input{A regex $e$ and a string $s$}
\Output{Either a match (with capture values) or no match}
\hlet{o = build\_oracle(r,s)}\;
\hlet{bc = compile(\regex{.*?(e)}$_{\#0}$)}\;
\hlet{result = VM(bc, $s$, $o$, forward)}\;
\match{result}{
  \case{No match}{No match}
  \case{match with captures $(c,m)$}{match with get\_missing\_captures($c$,$m$)}
  }
\caption{Matching the main expression}\label{alg:main}
\end{algorithm}




\subsection{Final Step: Extracting missing capture groups}

\todo{we should add initial capture values as argument to the VM, as well as initial cp and m}
\todo{the current pseudocode does not update anything}

Algorithm~\ref{alg:missing} shows how we reconstruct the missing capture groups.
We simply run a NFA-simulation of each lookaround that was used to produce the main match.
This time, this NFA-simulation is run forward for lookaheads and backward for lookbheinds, to comply with the capture semantics inside lookarounds.
We start the NFA-simulation exactly at the input string position where the lookaround was used.

\begin{algorithm}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\SetKwFor{match}{match}{with}{end}
\SetKwFor{case}{case}{\texttt{=>}}{}
\SetKw{hlet}{let}
\SetAlgoLined
\Input{A regex $e$ and a string $s$, and a lookaround memory $m$ indicating when each lookaround was used in a match}
\Output{All capture group values}
\For{i=1 \textbf{to} $\looknb{e}$}{
  \hlet{look = $\mathit{rev}(e_{\Box i})$}\;
  \hlet{bc = compile(look)}\;
  \If{m[i] = Some cp}{
    \match{$e_{\Box i}$}{
      \case{Lookahead}{VM(bc, $s$[cp:], $o$, forward)}
      \case{Lookbehind}{VM(bc, $s$[:cp], $o$, backward)}
    }
  }
}
\Return $o$\;
\caption{Getting capture groups defined in positive lookarounds \texttt{get\_missing\_captures}}\label{alg:missing}
\end{algorithm}

\section{Example of running the algorithm}

Consider the following regex \regex{(?:a(?=a(.))*(.)|a*(b)} on string \str{aaab}.
This regex gets annotated as follows: \lstinline[style=rgx]{(?:a(?=$_{\Box 1}$a(.)$_{\#1}$)*(.)$_{\#2}$|a*(b)$_{\#3}$}.

\paragraph{First step - Building the oracle}
In our first step, we build the oracle.
The oracle has a single row (we have a single lookahead) and 5 columns (the string has 4 characters).
We compute $\mathit{rev}($\regex{a(.)}$)=$\regex{(.)a}.
We can then compile to bytecode the expression \regex{.*?(.)a}. We can even remove the group around the dot as capture does not matter in this step.

\begin{lstlisting}[style=byt]
0: Fork 3 1
1: ConsumeAll
2: Fork 3 1
3: ConsumeAll
4: Consume a
5: WriteOracle 1
\end{lstlisting}

Executing the VM backward on this bytecode will find matches at positions 2 (after having read \str{b} and \str{a}), 1 (having read \str{a} and \str{a}) and 0 (having read \str{a} and \str{a}).

\paragraph{Second step - Matching the main expression and groups \#0, \#2 and \#3}

Now it's time to compile and match the main expression.
Note that the entire lookahead will be compiled to a single bytecode instruction \bytecode{CheckOracle 1}.
We compile the regex \lstinline[style=rgx]{.*?((?:a(?=$_{\Box 1}$a(.)$_{\#1}$)*(.)$_{\#2}$|a*(b)$_{\#3}$)$_{\#0}$}.

\begin{lstlisting}[style=byt]
0: Fork 3 1
1: ConsumeAll
2: Fork 3 1
3: SetRegisterToCP 0 // start of group #0
4: Fork 5 15
5: Fork 6 11
6: ClearRegister 2
7: ClearMemory 1
8: Consume a
9: CheckOracle 1 // lookahead
10: Jmp 5
11: SetRegisterToCP 4 // start of group #2
12: ConsumeAll
13: SetRegisterToCP 5 // end of group #2
14: Jmp 21
15: Fork 16 18
16: Consume a
17: Jmp 15
18: SetRegisterToCP 6 // start of group #3
19: Consume b
20: SetRegisterToCP 7 // end of group #3
21: SetRegisterToCP 1 // end of group #0
22: Accept
\end{lstlisting}

Executing the VM forward on this expression will find a best match where group \#0 is \str{aaa}, group \#1 is undefined, group \#2 is \str{a} (between positions 2 and 3) and group \#3 is undefined.
Since the left branch has priority over the right one, as soon as a match is found on the left, threads executing the right part of the NFA are discarded.
Since the star is greedy, threads that keep executing the loop have top priority.
At position however, after checking the oracle, we realize that the lookahead does not hold anymore, and the top priority match that is returned is the one that went into the loop 2 times.

The values for groups \#0, \#2 and \#3 are correct because these groups are defined inside the main expression.
However, group \#1 is defined inside a lookahead.

\paragraph{Final step - Getting the value of group \#1}

We now reconstruct the value of group \#1.
We can see that in the match returned in the last step, the thread last used the oracle for this lookahead at position 2.
We then run the VM forward on \lstinline[style=rgx]{a(.)$_{\#1}$}.

\begin{lstlisting}[style=byt]
0: Consume a
1: SetRegisterToCP 2 // start of group #1
2: ConsumeAll
3: SetRegisterToCP 3 // end of group #1
4: Accept
\end{lstlisting}

This finds a match, where the value of group \#1 is \str{b}.
We now have the full results of matching \regex{(?:a(?=a(.))*(.)|a*(b)} on string \str{aaab}.


\section{Complexity Analysis}

\paragraph{First step complexity}
For each lookaround, we run a NFA-simulation on the entire string.
The bytecode size of each lookaround is linear with its \textit{intrinsic size}.
As a result, for each lookaround $\re_{\Box i}$, constructing the $i$-th row of the oracle has time complexity $\bigo(\size{s} * \psize{\re_{\Box i}})$.
Finally, the complexity of building the entire oracle is $\bigo(\sum_{i=1}^{\looknb{r}} \size{s} * \psize{\re_{\Box i}})$.
Using the intrinsic size equality, this is $\bigo(\size{s} * \size{\re})$.

The asymptotical space complexity of this first step is also $\bigo(\size{s} * \size{\re})$, given that both the array itself and each NFA-simulation have this complexity.

\paragraph{Second step complexity}
This step simply consists in running a NFA-simulation on the entire string and the main expression.
Since lookarounds are simply compiled to a single \bytecode{CheckOracle} instruction, this has complexity $\bigo(\size{s} * \psize{e})$.

\paragraph{Third step complexity}
This step may require as many NFA-simulations as there are lookarounds in $e$.
For each lookaround i, this has complexity $\bigo(\size{s} * \psize{\re_{\Box i}})$.
Then entire loop then has complexity $\bigo(\sum_{i=1}^{\looknb{r}} \size{s} * \psize{\re_{\Box i}})$.
Using the intrinsic size equality, this is $\bigo(\size{s} * \size{\re})$.

\paragraph{Total complexity}
In conclusion, running the three steps of our algorithm has spatial and memory complexity $\bigo(\size{s} * \size{\re})$.
Previously, unbounded lookarounds were only matched by backtracking regex engines, with possible exponential time complexity.
Our algorithm shows that the VM-based NFA-simulation approach can be adapted to match an extended language of regexes with unbounded lookarounds, without changing its linear complexity.

\section{Limitations}

\paragraph{Remark on streaming mode}
An engine like RE2 only ever reads the input string from its beginning to its end.
As a result, it can also work in streaming mode, where the input string is being processed on-the-fly;
Due to the fact that we analyze lookaheads and negative lookaheads in the backward direction, our algorithm is not compatible with streaming mode.

\section{Conclusion}



\newpage
\bibliography{main.bib}

\end{document}
