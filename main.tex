\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{url}
\usepackage{lipsum}
\usepackage{geometry}
\usepackage[tt=false]{libertine}
\usepackage{xcolor}
\bibliographystyle{apalike}
\citestyle{acmauthoryear}   %% For author/year citations
\renewcommand\cite\citep
\usepackage{syntaxdefs}
\usepackage{graphicx}
\usepackage{listings}

\usepackage[bookmarksnumbered,unicode]{hyperref} %Utiliser pour une bibliographie interactive + sommaire et TOC interactifs (pour une sortie PDF, par exemple).
\bibpunct{[}{]}{,}{a}{}{;}

\hypersetup{colorlinks,
      linkcolor=ACMPurple,
      citecolor=ACMPurple,
      urlcolor=ACMDarkBlue,
      filecolor=ACMDarkBlue}

\definecolor[named]{ACMBlue}{cmyk}{1,0.1,0,0.1}
\definecolor[named]{ACMYellow}{cmyk}{0,0.16,1,0}
\definecolor[named]{ACMOrange}{cmyk}{0,0.42,1,0.01}
\definecolor[named]{ACMRed}{cmyk}{0,0.90,0.86,0}
\definecolor[named]{ACMLightBlue}{cmyk}{0.49,0.01,0,0}
\definecolor[named]{ACMGreen}{cmyk}{0.20,0,1,0.19}
\definecolor[named]{ACMPurple}{cmyk}{0.55,1,0,0.15}
\definecolor[named]{ACMDarkBlue}{cmyk}{1,0.58,0,0.21}


\lstdefinestyle{rgx}{ %
  xleftmargin=2\parindent,
  captionpos=b,
  mathescape,
  basicstyle=\ttfamily,
  commentstyle=\itshape\color{MidnightBlue},
  identifierstyle=\color{black},
  keywordstyle=\bfseries,
}



\def\regex#1{\lstinline[style=rgx]{#1}}
\def\tregex#1{\text{\regex{#1}}}

\def\todo#1{{\color{ACMOrange}{TODO: }}#1}
\def\undef{\texttt{undefined}}
\def\str#1{\texttt{"#1"}}
\def\group#1{\texttt{\##1}}

\geometry{vmargin=4.0cm}

\title{Regular Epressions with Lookarounds and Capture Groups Can Be Matched Linearly}
\author{}
\date{}



\begin{document}


\maketitle


\section{Context}

\subsection{Syntax}
We consider the following grammar of regular expressions:

\def\re{\ensuremath{\mathit{e}}}
\def\char{\ensuremath{\mathit{c}}}
\def\quant{\ensuremath{\mathit{q}}}

\begin{figure}[h]
  \begin{syntax}
    \syntaxclass{Regular Expressions:}
\re & ::= & \char & Character \\
&\mid& \re_1 ~ \re_2 & Concatenation\\
&\mid& \re_1 \tregex{|} \re_2 & Union\\
&\mid&  \re ~ \quant & Quantifier \\
&\mid&  \tregex{(}\re\tregex{)} & Capture Group \\
&\mid& \tregex{(?=}\re\tregex{)} & Positive Lookahead \\
&\mid& \tregex{(?!}\re\tregex{)} & Negative Lookahead \\
&\mid& \tregex{(?<=}\re\tregex{)} & Positive Lookbehind \\
&\mid& \tregex{(?<!}\re\tregex{)} & Negative Lookbehind \\
%
\syntaxclass{Quantifiers:}
\quant & ::=& \tregex{*} & Greedy Star\\
&\mid& \tregex{*?} & Lazy Star\\
&\mid& \tregex{+} & Greedy Plus\\
&\mid& \tregex{+?} & Lazy Plus\\
  \end{syntax}
\end{figure}

\subsection{Semantics}
\subsubsection{Backtracking Semantics}
\todo{semantics}


\subsubsection{Semantic Properties}
Here are some notable properties of the semantics, that may separate it from other extended regex languages.
Note that all these properties are properties of the JS regex language as well.

\paragraph{Unbounded Lookarounds}
Some languages (\emph{e.g.} Perl, Python, Java) only allow fixed-width lookarounds. Meaning that regular expression patterns inside lookaheads and lookbehinds should not contain quantifiers.
Here, we allow lookarounds with quantifiers.
For example, the regular expression \regex{(?=a*)} is allowed.

\paragraph{Capture Reset}
When executing a quantifier, the value of the capture groups defined inside that quantifier are reset to \undef.
For instance, matching \regex{((a)|(b))*} on string \str{ab} will return a match where group \group{2} is set to undefined.
On the first star iteration, \group{2} was set to the capture value \texttt{[0-1]}, matching the first character of the string.
When executing the second star iteration, \group{2} is reset to undefined, and group \group{3} is set to \texttt{[1-2]}, matching character \texttt{b}.
This means that only the last iteration of a quantifier in a successful match will set the values of the groups defined inside that quantifier.
This property holds for the JS regex language, but the behavior differs in the regex languages of Perl, Python, Java and .NET.

\paragraph{No negative captures}
Note that negative lookahead and negative lookbehinds do not define any capture groups.
You can write the regular expression \regex{(?!(a))}, but group \group{1} will always be \undef.
As a result, \regex{(?!(?!e))} is not equivalent to \regex{(?=e)}.
This appears to be a property shared by most regex languages with negative lookarounds.

\paragraph{Quantifiers that did not consume any characters do not capture anything}
Lookarounds do not consume characters, meaning that the current position of the string does not change after matching a lookaround.
If the regular expression inside a quantifier does not consume any character, then the capture groups values inside that quantifiers are discarded.
For instance, when matching \regex{(?=(a))*a} on string \str{a}, capture group \group{1} will be \undef.
This property holds for the JS regex language, but the behavior differs in the regex languages of Perl, Python, Java and .NET.


\section{A Linear Algorithm for Loookarounds and Capture Groups}

\subsection{Preliminary Definitions}

Before describing our algorithm, we need the following definitions.

\paragraph{Capture Group Annotations}
We annotate each regex with a different identifier for each capture group.
Some regex languages (like .NET) allow different capture groups to have the same identifiers using named capture groups.
Others (like JS, PCRE and Java) disallow this. In this work, we associate unique identifiers to each capture group.

% TODO: why does using the regex macro not work here with subscript???
For instance, the regex \regex{a(b)(c)} gets annotated to \lstinline[style=rgx]{a$(b)_1$(c)$_2$} and \regex{a((b))} gets annotated to \lstinline[style=rgx]{a((b)$_2$)$_1$}.
Groups are annotated in order of a depth-first AST traversal, starting with 1.
Before matching a regex, we add a new capture group around the entire expression annotated with index 0, mimicking the JS behavior.

\paragraph{Lookaround Annotations}
Similarly, we annotate each lookaround with an unique identifier.
Identifiers are integers given in order of a depth-first AST traversal.
This ensures that if lookaround $l_1$ contains another lookaround $l_2$, then the index of $l_1$ is smaller than the index of $l_2$.
For instance, the regex \regex{(?=a(?<=a))a} gets annotated to \lstinline[style=rgx]{(?=$_1$a(?<=$_2$a))a}.
We write $\mathit{looks}(r)$ the total number of lookarounds in a regex $r$.
For instance, $\mathit{looks}(\tregex{(?=a(?<=a))a}) = 2$.

\subsection{Main Intuitions}



\subsection{Bytecode Generation}

\subsection{First Step: Constructing the Oracle}

\subsection{Second Step: Finding Capture Groups}

\section{Complexity Analysis}

\section{Limitations}

\section{Conclusion}



\newpage
\bibliography{main.bib}

\end{document}
